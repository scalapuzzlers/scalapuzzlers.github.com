<h1>I Can Has Padding?</h1>
<table class="table meta-table table-condensed">
  <tbody>
    <tr>
      <td class="header-column"><strong>Contributed by</strong></td>
      <td>A. P. Marki<br/>Updated based on suggestions by Luc Bourlier</td>
    </tr>
    <tr>
      <td><strong>Source</strong></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><strong>First tested with Scala version</strong></td>
      <td>2.10.0</td>
    </tr>
  </tbody>
</table>
<div class="code-snippet">
  <h3>What is the result of executing the following code?</h3>
<pre class="prettyprint lang-scala">
implicit class Padder(val sb: StringBuilder) extends AnyVal {
  def pad2(width: Int) = {
    1 to width - sb.length foreach { sb append '*' }
    sb
  }
}

// greeting.length == 14
val greeting = new StringBuilder("Hello, kitteh!")
println(greeting pad2 20)

// farewell.length == 9
val farewell = new StringBuilder("U go now.")  // I hatez long bye-bye.
println(farewell pad2 20)
</pre>
  <ol>
<li>Prints:
<pre class="prettyprint lang-scala">
Hello, kitteh!******
U go now.***********
</pre></li>
<li id="correct-answer">
	The first one succeeds and prints:
<pre class="prettyprint lang-scala">
Hello, kitteh!*
</pre>
	and the second one fails with a runtime exception
</li>
<li>
	The first one fails with a runtime exception and the second one prints:
<pre class="prettyprint lang-scala">
U go now.***********
</pre></li>
<li>
Does not compile
</li>
  </ol>
</div>
<button id="show-and-tell" class="btn btn-primary" href="#">Display the correct answer, explanation and comments</button>
<div id="explanation" class="explanation" style="display:none">
  <h3>Explanation</h3>
  <p>
Recall that Scala has a <tt>StringBuilder</tt> that <a href="http://www.artima.com/pins1ed/working-with-lists.html#footnote16-5">shadows <tt>java.lang.StringBuilder</tt></a> and that it has an <a href="http://www.scala-lang.org/api/current/index.html#scala.collection.mutable.StringBuilder"><tt>apply</tt></a> method.
  </p>
  <p>
The <tt>foreach</tt> takes a function with an Int parameter. <tt>StringBuilder.append</tt> returns a <tt>StringBuilder</tt>, and <tt>StringBuilder</tt> extends <tt>Function1</tt>, so the compiler can just use the returned value as the argument to the <tt>foreach</tt> call. Each iteration invokes <tt>StringBuilder.apply</tt>, which is an alias for <tt>StringBuilder.charAt</tt>.
  </p>
  <p>
The code generated by the compiler is equivalent to the following:
  </p>
  <p>
<pre class="prettyprint lang-scala">
def pad2(width: Int) = {
  // the StringBuilder returned by append is a function!
  val sbAsFunction: Function1[Int, Char] = sb.append('*') // the same sb that was 
                                                          // passed to Padder
  (1 to (width - sb.length)).foreach(sbAsFunction)
  sb
}
</pre>
  </p>
  <p>
If we unroll the loop, the reason for the exception becomes clear. In the case of the shorter string, the <tt>StringBuilder</tt> contains only ten characters (<tt>U go now.*</tt> after the call to <tt>append()</tt>. So the <tt>apply</tt> - <tt>charAt</tt> - call fails on the tenth iteration:
  </p>
  <p>
<pre class="prettyprint lang-scala">
def pad2(width: Int) = {
  val sbAsFunction: Function1[Int, Char] = sb.append('*')
  sbAsFunction.apply(1)
  ...
  sbAsFunction.apply(9)
  sbAsFunction.apply(10) // fails here
  sbAsFunction.apply(11)
  sb
}
</pre>
  </p>
  <p>
You can get the expected behaviour, answer #1, by explicitly specifying the function literal to be used:
  </p>
  <p>
<pre class="prettyprint lang-scala">
def pad2(width: Int) = {
  1 to (width - sb.length) foreach (_ =&gt; sb append '*')
  sb
}
</pre>
  </p>
  <p>
Alternatively:
  </p>
  <p>
<pre class="prettyprint lang-scala">
// Reducing type inference can confirm or deny expectations
(1 to (width - sb.length)).foreach[Unit](sb.append('*')) // does not compile

// StringBuilder.padTo is inherited from SeqLike
println("U go now." padTo (20, '*'))                     // the expected String
println(new StringBuilder("U go now.") padTo (20, '*'))  // ArrayBuffer(U,  , g, o,  , n, o, w, ...

// One can build Strings from a StringBuilder, can't one?
import collection.generic.CanBuildFrom
import collection.mutable.Builder
implicit def cbf = new CanBuildFrom[StringBuilder, Char, String] {
  def apply(): Builder[Char, String] = new StringBuilder
  def apply(from: StringBuilder): Builder[Char, String] = new StringBuilder(from.length)
}
// This uses a new intermediate builder and copies before padding.
// The unspecialized ++= operation is a grisly oldsb foreach { newsb += }
val mysb = new StringBuilder("U go now.")
println(mysb padTo (20, '*')) // the expected String, but built a *new* StringBuilder instance
                              // mysb still contains "U go now."

// One could go to greater lengths to reuse the builder
class StringBuilderBuilder(private var sb: StringBuilder) extends Builder[Char, StringBuilder] {
  // in lieu of { a; this }, a thistly idiom; thisly benefits from -optimise
  @inline private def thisly[A](a: A): this.type = this
  // attempt to intercept the initial copy
  override def ++=(s: collection.TraversableOnce[Char]): this.type = thisly {
    s match {
      case k: StringBuilder if sb.isEmpty => sb = k
      case k: StringBuilder               => sb append k.toString
      case _                              => sb ++= s

    }
  }
  override def +=(c: Char): this.type = thisly { sb += c }
  override def clear() { sb.clear() }
  override def result(): StringBuilder = sb
}
implicit def canBuilder = new CanBuildFrom[StringBuilder, Char, StringBuilder] {
  def apply(): Builder[Char, StringBuilder] = new StringBuilderBuilder(new StringBuilder)
  // reuse the StringBuilder we're building from
  //def apply(from: StringBuilder): Builder[Char, StringBuilder] = apply()
  def apply(from: StringBuilder): Builder[Char, StringBuilder] = new StringBuilderBuilder(from)
}
val mysb = new StringBuilder("U go now.")
val resb = mysb padTo (20, '*')                         // get our StringBuilder back
assert(mysb eq resb)
println(resb.toString)                                  // the expected String
</pre>
  </p>
</div>
