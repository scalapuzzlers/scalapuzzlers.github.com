<h1>Doesn't apply to me</h1>
<table class="table meta-table table-condensed">
  <tbody>
    <tr>
      <td class="header-column"><strong>Contributed by</strong></td>
      <td>Luc Bourlier</td>
    </tr>
    <tr>
      <td><strong>Source</strong></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><strong>Tested with Scala version</strong></td>
      <td>2.9.2</td>
    </tr>
  </tbody>
</table>
<div class="code-snippet">
  <h3>What is the result of executing the following code?</h3>
  <pre class="prettyprint lang-scala">
def padding(sb: StringBuilder): StringBuilder = {
  0 until 4 foreach {
    sb.append('*')
  }
  sb
}

val sb1 = new StringBuilder("abc")
println(padding(sb1))

val sb2 = new StringBuilder("")
println(padding(sb2))
</pre>
  <ol>
    <!--
      The correct answer should have id for corresponding li element equal to "correct-answer".
      When placing code snippets wrap them with pre tag:
      <pre class="prettyprint lang-scala">
        ...
      </pre>
     -->
    <li><pre class="prettyprint lang-scala">
abc
 
</pre></li>
    <li><pre class="prettyprint lang-scala">
abc****
****
</pre></li>
    <li id="correct-answer"><pre class="prettyprint lang-scala">
abc*
java.lang.StringIndexOutOfBoundsException: String index out of range: 1
</pre></li>
    <li><pre class="prettyprint lang-scala">
java.lang.StringIndexOutOfBoundsException: String index out of range: 3
java.lang.StringIndexOutOfBoundsException: String index out of range: 0
</pre></li>
  </ol>
</div>
<button id="show-and-tell" class="btn btn-primary" href="#">Display the correct answer, explanation and comments</button>
<div id="explanation" class="explanation" style="display:none">
  <h3>Explanation</h3>
  <p>
    <p><tt>Range#foreach(..)</tt>, like most of the methods in the Scala collections, take a function as parameter.</p>
    <p>And if needed, the compiler is able to create a function from a method call.</p>
    <p>But it is not the case in this example. A call to <tt>StringBuilder#append(..)</tt> returns itself, and <tt>StringBuilder</tt> extends <tt>Function1</tt>, so the compiler can just use the returned value as the parameter for the <tt>foreach</tt> call.</p>
    The code generated by the compiler is equivalent to the following:
    <pre class="prettyprint lang-scala">
def padding(sb: StringBuilder) {
  val theSameSb: StringBuilder = sb.append('*')
  (0 until 4).foreach(theSameSb)
  sb
}
    </pre>
If we expand the loop, the reason of the exception becomes visible. In the <tt>sb2</tt> case, The <tt>StringBuilder</tt> contains only one character after the call to <tt>append()</tt>. So the call to get the 2nd element fails.
    <pre class="prettyprint lang-scala">
def padding(sb: StringBuilder) {
  val theSameSb = sb.append('-')
  theSameSb(0)
  theSameSb(1)  // &lt;-- fails here
  theSameSb(2)
  theSameSb(3)
  sb
}
    </pre>
The fix to get the expected behavior is to explicitly create the function to be used:
    <pre class="prettyprint lang-scala">
def padding(sb: StringBuilder) {
  0 until 4 foreach {
    i =&gt; sb.append('*')      
  }
  sb
}
    </pre>
  </p>
</div>

