<h1>You Blockhead!</h1>
<table class="table meta-table table-condensed">
  <tbody>
    <tr>
      <td class="header-column"><strong>Contributed by</strong></td>
      <td>A. P. Marki</td>
    </tr>
    <tr>
      <td><strong>Source</strong></td>
      <td><a target="_blank" href="https://groups.google.com/d/msg/scala-user/x_Y4uxe9ruc/MJ1QiFVy5ZAJ">scala-user mailing list</a></td>
    </tr>
    <tr>
      <td><strong>Tested with Scala version</strong></td>
      <td>2.10.2</td>
    </tr>
  </tbody>
</table>
<div class="code-snippet">
  <h3>What is the result of executing the following code?</h3>
<pre class="prettyprint lang-scala">
class A {
  def apply(n: Int) = n * 2
}
class B extends A {
  override def apply(n: Int) = n * 3
}
object Foo {
  def f(n: Int)(implicit o: A) = o(n)
}
object Bar {
  import Foo._
  implicit val a = new A
  Console println f(3)
  implicit val b = new B
  Console println f(5)
}
object Baz {
  import Foo._
  def baz = {
    implicit val a = new A
    Console println f(3)
    implicit val b = new B
    Console println f(5)
  }
}
Bar       // run the initializer
Baz.baz
</pre>
  <ol>
    <li>
<pre class="prettyprint lang-scala">
6
15
6
15
</pre>
    </li>
    <li id="correct-answer">The first statement throws an exception and the second prints:
<pre class="prettyprint lang-scala">
6
15
</pre>
    </li>
    <li>
<pre class="prettyprint lang-scala">
9
15
9
15
</pre>
    </li>
    <li>
Both statements fail to compile.
    </li>
  </ol>
</div>
<button id="show-and-tell" class="btn btn-primary" href="#">Display the correct answer, explanation and comments</button>
<div id="explanation" class="explanation" style="display:none">
  <h3>Explanation</h3>
  <p>
The implicit 'B' is more specific than 'A' because 'B' conforms to 'A' but not conversely. 
See SLS 6.26.3, the fourth bullet point of the definition of "as specific as",
which mentions "existential duals".
For this exercise, the take-away is: 
"The existential dual of every other type is the type itself."
  </p>
  <p>
In the template Bar, both implicits are in scope and 'b' is more specific,
but 'b' is not yet initialized at the first application.
  </p>
  <p>
In the block body of the method 'baz', the implicits become eligible at their
point of definition, so the method executes as one might usually expect.
  </p>
</div>
