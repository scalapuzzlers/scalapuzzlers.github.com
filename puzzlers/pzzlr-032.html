<h1>Type Extortion</h1>
<table class="table meta-table table-condensed">
  <tbody>
    <tr>
      <td class="header-column"><strong>Contributed by</strong></td>
      <td>A. P. Marki</td>
    </tr>
    <tr>
      <td><strong>Source</strong></td>
      <td><a target="_blank" href="https://groups.google.com/d/topic/scala-user/KfNiYa1YoPM/discussion">scala-lang mailing list</a></td>
    </tr>
    <tr>
      <td><strong>Tested with Scala version</strong></td>
      <td>2.10.1</td>
    </tr>
  </tbody>
</table>
<div class="code-snippet">
  <h3>What is the result of executing the following code?</h3>
<pre class="prettyprint lang-scala">
  val (x, y) = (List(1,3,5), List(2,4,6)).zipped find (_._1 > 10) getOrElse (10)

Console println s"Found $x"
</pre>
  <ol>
    <!--
      The correct answer should have id for corresponding li element equal to "correct-answer".
      When placing code snippets wrap them with pre tag:
      <pre class="prettyprint lang-scala">
        ...
      </pre>
     -->
    <li>Found 10</li>
    <li>Found ()</li>
    <li>Does not compile.</li>
    <li id="correct-answer">Throws an exception.</li>
  </ol>
</div>
<button id="show-and-tell" class="btn btn-primary" href="#">Display the correct answer, explanation and comments</button>
<div id="explanation" class="explanation" style="display:none">
  <h3>Explanation</h3>
  <p>
  The bully who stole your milk money used to say: "Give it to me -- or else!"
  </p>
  <p>
  But he was never satisfied and would always take as much as he could get.
  </p>
  <p>
In Scala, the "or else" idioms, such as Option.orElse, Option.getOrElse, or Try.recover and Future.recover,
are defined to accept a wider type than you start with:
  </p>
  <p>
<pre class="prettyprint lang-scala">
  def getOrElse[B >: A](default: â‡’ B): B 
</pre>
  </p>
  <p>
If you don't supply a value of the type it wants, it will take whatever it can, including Any thing at all.
  </p>
  <p>
In this case, Any is inferred for B, and there is no type error to show that an Int was used as an alternative
for a pair of Ints. In the absence of a type on the pattern definition, the pattern match throws a MatchError
at runtime.
  </p>
  <p>
Even without a mistaken change in arity, similar typographic errors are possible with swapped elements:
  </p>
  <p>
  <pre class="prettyprint lang-scala">
  val (num, name) = Option(Pair(7, "seven")) getOrElse Pair("eight", 8)
  </pre>
  </p>
  <p>
That suggests that testing of these alternative code paths should be enforced by a code coverage tool.
It may be that the "orElse" represents a default value that is never exercised in normal usage.
  </p>
  <p>
  Fixes include specifying the expected type:
  <pre class="prettyprint lang-scala">
  val (num, name): (Int, String) = Option(Pair(7, "seven")) getOrElse Pair("eight", 8)
  </pre>
  </p>
  <p>
  Or using a method that eliminates the inferred type:
  <pre class="prettyprint lang-scala">
  implicit class OptionSafe[A](val opt: Option[A]) extends AnyVal {
    def getOrElseSafe(default: => A): A = opt getOrElse default
  }
  val (num, name) = Option(Pair(7, "seven")) getOrElseSafe Pair("eight", 8)
  </pre>
  </p>
</div>
