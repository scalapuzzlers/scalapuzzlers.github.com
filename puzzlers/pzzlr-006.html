<h1>The Missing List</h1>
<table class="table table-condensed">
  <tbody>
    <tr>
      <td><strong>Contributed by</strong></td>
      <td>Andrew Phillips & Nermin Serifovic</td>
    </tr>
    <tr>
      <td><strong>Source</strong></td>
      <td><a target="_blank" href="http://stackoverflow.com/questions/7040806/when-applying-map-to-a-set-you-sometimes-want-the-result-not-to-be-a-set-but">stackoverflow</a></td>
    </tr>
    <tr>
      <td><strong>Tested with Scala version</strong></td>
      <td>2.9.2</td>
    </tr>
  </tbody>  
</table>
<div class="code-snippet">
  <h3>What does the following code print?</h3>
  <pre class="prettyprint lang-scala">
def sumSizes(collections: Iterable[TraversableOnce[_]]): Int = collections.map(_.size).sum

sumSizes(List(Set(1, 2), List(3, 4)))
sumSizes(Set(List(1, 2), Set(3, 4)))
</pre>
  <ol>  
    <li>
      <pre class="prettyprint lang-scala">
Int = 4
Int = 4
</pre>
    </li>
    <li id="correct-answer">
      <pre class="prettyprint lang-scala">
Int = 4
Int = 2
</pre>
    </li>
    <li>
      <pre class="prettyprint lang-scala">
Int = 2
Int = 4
</pre>
    </li>
    <li>
      <pre class="prettyprint lang-scala">
Int = 2
Int = 2
</pre>
    </li>
  </ol>
</div>
<button id="show-and-tell" class="btn btn-primary" href="#">Display the correct answer and explanation</button>
<div id="explanation" class="explanation" style="display:none">
  <h3>Explanation</h3>
  <p>
	Even though collections.map would appear to map an iterable to 
	another "nice" iterable, since the Collections Redesign the type of 
	the returned iterable will (usually) match the input type. Which, for 
	sets, means...no duplicates.
	And yes, foldLeft would obviously be a much nicer way to do this <img src="img/smiley.jpg" alt=":)"/>
</p>
</div>

