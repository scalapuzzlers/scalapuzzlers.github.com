<h1>Sequence match puzzler</h1>
<table class="table meta-table table-condensed">
  <tbody>
    <tr>
      <td class="header-column"><strong>Contributed by</strong></td>
      <td>Scala Team @ Razorfish</td>
    </tr>
    <tr>
      <td><strong>Source</strong></td>
      <!--
        If no source (your puzzler is not mentioned anywhere on the web), just say N/A
      --> 
      <td><a target="_blank" href="N/A">N/A</a></td>
    </tr>
    <tr>
      <td><strong>First tested with Scala version</strong></td>
      <td>2.11.7</td>
    </tr>
  </tbody>
</table>
<div class="code-snippet">
  <h3>What is the result of executing the following code?</h3>
<pre class="prettyprint lang-scala">
  import java.util.{List => JList, LinkedList}
  import scala.collection.JavaConversions._

  def listFromJava: JList[Int] = {
    val jlist = new LinkedList[Int]()
    jlist.add(1)
    jlist.add(2)
    jlist
  }

  def printHeadOrEmpty(s: Seq[_]) = s match {
     case hd :: _ => println(hd)
     case _ => println("Empty :-(")
  }

  printHeadOrEmpty(listFromJava.toSeq)
  printHeadOrEmpty(Seq(listFromJava: _*)) 
</pre>
  <ol>
    <!--
      The correct answer should have id for corresponding li element equal to "correct-answer".
      When placing code snippets wrap them with pre tag:
      <pre class="prettyprint lang-scala">
        ...
      </pre>
     -->
    <li id="correct-answer">Prints
      <pre class="prettyprint lang-scala">
1
Nothing
      </pre>
    </li>
    <li>Prints
      <pre class="prettyprint lang-scala">
Nothing
1
      </pre>
    </li>
    <li>Prints
      <pre class="prettyprint lang-scala">
1
1
      </pre>
    </li>
    <li>Prints
      <pre class="prettyprint lang-scala">
Nothing
Nothing
      </pre>
    </li>
  </ol>
</div>
<button id="show-and-tell" class="btn btn-primary" href="#">Display the correct answer, explanation and comments</button>
<div id="explanation" class="explanation" style="display:none">
  <h3>Explanation</h3>
  <p>
    The frenquently used type Seq is an interface with an apply method that returns a List when called so seq1 is List(1,2,3) therefore matches the first case.
    The java conversion method that's invoked when we call toSeq on a LinkedList returns a Buffer which does not match the first case (only scala Lists have a :: defined on them). To catch all sequences we should have used the +: for the matching case.
  </p>
  <p><strong>More insight</strong></p>
  <p>
    Seq can't be instantiated, so Scala has to pick a subtype when you declare something as a Seq.  In the case of Seq(1, 2, 3), it chooses List, because that's the default.  But Scala apparently understands that LinkedList is a mutable collection, and JavaConversions defaults to a mutable class that is generic enough to cover any kind of mutable Java list, namely Buffer.

    Now, you'd think that there would be a type error there because on the one hand seq1 is a scala.collection.Seq, and on the other hand seq2 is a scala.collection.mutable.Seq, but scala.collection.mutable.Seq mixes in the collection.Seq trait, so they both count as a collection.Seq.  So really what's happening is that we're equivocating between two distinct types that are both called Seq, and which are interchangeable based on their type signature.  So you can miss the fact that they are actually different, and that they default to different instantiated collections
  </p>
</div>