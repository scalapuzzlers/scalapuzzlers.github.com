<div id="title">
  <h1>If At First You Don't Succeed...</h1>
</div>
<table class="table meta-table table-condensed">
  <tbody>
    <tr>
      <td class="header-column"><strong>Contributed by</strong></td>
      <td>Konstantine Golikov</td>
    </tr>
    <tr>
      <td><strong>Source</strong></td>
      <td><a target="_blank" href="http://stackoverflow.com/questions/9449474/def-vs-val-vs-lazy-val-evaluation-in-scala/9450146#9450146">stackoverflow</a></td>
    </tr>
    <tr>
      <td><strong>Tested with Scala version</strong></td>
      <td>2.10.0</td>
    </tr>
  </tbody>  
</table>
<div class="code-snippet">
  <h3>What is the result of executing the following code?</h3>
<pre class="prettyprint lang-scala">
var x = 0
lazy val y = 1/x
try {
  println(y)
} catch {
  case _ : Throwable =>
    x = 1
    println(y)
}
</pre>
  <ol>  
    <li>Throws a 'divide by zero' exception</li>
    <li id="correct-answer">Prints
<pre class="prettyprint lang-scala">
1
</pre>
    </li>
    <li>Prints
<pre class="prettyprint lang-scala">
NaN
</pre>
</li>
    <li>Prints
<pre class="prettyprint lang-scala">
&lt;lazy&gt;
</pre>
</li>
  </ol>
</div>
<button id="show-and-tell" class="btn btn-primary" href="#">Display the correct answer, explanation and comments</button>
<div id="explanation" class="explanation" style="display:none">
  <h3>Explanation</h3>
  <p>
    One of the most interesting things about lazy values (besides that they defer actual computation) is that they will be recomputed on call if there was an exception at the moment of first access, until some definite value is acquired. So you can use this useful pattern in many situations, for example to handle missing files.
  </p>
</div>
